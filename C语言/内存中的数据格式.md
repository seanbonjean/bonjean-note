# 内存中的数据格式

## 整型：原码、反码和补码

补码是内存中实际存储的值，原码和反码只是为了好理解和方便计算而创造的概念

### “取反加一”规则

正数：原反补相同  
负数：原码取反得到反码，反码加一得到补码

注意：无论是取反还是加一，最高位符号位都不变

### 内存中的值与有无符号类型的对应关系

以char型为例：

|内存中|char|unsigned char|
|-|-|-|
|00|0|0|
|...|...|...|
|7f|127|127|
|80|-128|128|
|...|...|...|
|ff|-1|255|

值由上往下依次增大

### 特例的一般化

表格中，-128的补码对应80，这似乎是个特例，但事实上这也符合“取反加一”规则，解释如下：
* 解1：原码：80 --取反--> 反码：ff --加一--> 补码：80
* 解2：通过公式求：x的补码 = 该数据类型模的大小 - |x|（x仅限负数）

## 浮点型

### 预先整理

1. 将十进制转换为二进制，如10.25D = 1010.01B
2. 写为指数形式，接上例：1010.01 = +1.01001 x 2^3
3. 把结果分成三部分，按照IEEE754标准，分为符号位、指数位和尾数位

### 分别存储

三部分在32位float中为1-8-23分布，64位double中为1-11-52分布

1. 符号位：永远是第一位，0正1负
2. 指数位：最好叫做“偏移后”指数位，以无符号整型方式存储偏移后的指数
   * 存储的整数 = 实际指数 + 偏移量
   * 偏移的存在是为了确保负指数能够以无符号格式存储
   * 32位float中偏移127，64位double中偏移1023
   * 如上例中的“3”为“偏移前”指数，若为float，需要加偏移量127，得到“偏移后”指数“130”，也就是1000 0010
3. 尾数位：“去1补0”
   * “去1”：因为最高位一定是1，可以省略提高存储效率，即1.01001中只需存储01001
   * “补0”：很少有浮点数能像这个例子一样末尾能算完的，不过如果真有，那最后几位肯定要补成0，如01001补成010 0100 0000 0000 0000 0000(一共23位)

按照这个例子，10.25按float存储，在内存中就是：
|符号位|指数位|尾数位|
|-|-|-|
|0|1000 0010|010 0100 0000 0000 0000 0000|

也即0100 0001 0010 0100 0000 0000 0000 0000，即0x41240000
