# 线性表

## 定义

相邻数据元素存在序偶关系<ai-1, ai>，称ai-1为ai的前驱，ai为ai-1的后继

## 顺序表

逻辑结构：线性表  
存储结构：顺序存储

顺序表是***随机存取结构***，计算任意数据元素的地址的时间都相等

需要的辅助变量：length、max_size

## 链表

逻辑结构：线性表  
存储结构：链接存储

链表是***顺序存取结构***，计算任意数据元素的地址的时间依赖于数据元素的个数，即查找时需要遍历（注意区分顺序存储结构和顺序存取结构）

### 结点

单链表中：{data, next}  
双链表中：{data, prev, next}

称data为数据域，prev、next为指针域

引入头结点的作用：
1. 插入/删除操作无需特例对待
2. 可以作为循环链表遍历时的终止条件

### 插入新结点

指导思想：先切入新结点，再修改插入位置的前驱后继关系

单链表：先修改新节点的next，再修改前驱结点的next  
双链表：先修改新节点的prev、next，再修改前驱结点的next和后继结点的prev

### 循环链表

循环链表的末端结点指回头结点

#### 为何改用“尾指针”？

采用头指针时：查找头结点O(1)，查找尾结点O(n)  
采用尾指针时：查找头结点O(1)，查找尾结点O(1)

改用尾指针，找尾结点不用再从头遍历到底，而找头结点只需往下走两步

## 两种线性表的对比

### 时间性能

顺序表：随机存取，查找/修改O(1)，插入/删除O(n)  
链表：顺序存取，查找/修改O(n)，插入/删除O(1)

### 空间性能

顺序表：需要预分配存储空间，容易一次分配太多/不够，难以实现存储空间的动态分配。适合数据元素个数变动不大的情况  
链表：指针的存储产生了额外开销，但可以实现存储空间的动态分配，适合数据元素个数变动较大的情况

## 扩展内容

### 静态链表

静态链表用数组模拟内存，通过数组下标代替内存地址的方式，起到链表功能的同时相比链表要节约存储空间

| |链表|静态链表|
|-|-|-|
|指针域|内存地址|数组下标|
|查找|内存寻址|依据下标寻址|

示例：
|data|next|
|-|-|
|data1|1|
|data2|3|
|data4|NULL|
|data3|2|

其中next表示下一个结点在数组中的下标

静态链表的实现是一个以{data, next}作为数据元素的一维数组

### 顺序表的动态分配

一言以蔽之：不够用就再calloc，用多了就free  
按这个需求做一个系统出来就可以实现顺序表的动态分配

## 栈和队列

### 栈

栈是一种**后进先出**的数据结构，只能在一端进行插入（压栈）和删除（弹栈）操作

栈可用于消除递归：递归算法 = 栈 + 非递归算法

因为栈是限定了插入删除规则的线性表，所以栈的实现也有两种：
* 顺序栈：通过辅助变量top来指示栈顶元素
* 链栈：是链表的一种特例，由于栈的插入删除规则，它不需要头节点

### 队列

队列是一种**先进先出**的数据结构，只能在队尾插入元素，在队首删除元素

队列可用于实现进程/线程的同步：生产者-消费者问题

队列也是限定了插入删除规则的线性表，它的实现也有两种：

#### 顺序队列

* 如果按一般思路，必须从头排：插入/删除O(n)，但只需一个指针rear
* 如果采用**循环队列**：插入/删除O(1)，需要两个指针front、rear分别指示队首和队尾元素

在循环队列中，规定：
| | |队首| | |队尾| | |
|-|-|-|-|-|-|-|-|
| |front| | | |rear| | |

这样可使length = (rear - front + max_size) % max_size

入队时 rear = (rear + 1) % max_size  
出队时 front = (front + 1) % max_size  
队满条件：front == (rear + 1) % max_size，即必须空出一个存储空间  
因为队空条件：front == rear，如果不空一个，队满也是front == rear，无法区分

#### 链队列

两个辅助指针front、rear分别指示队首和队尾元素  
注意：队列中仅存的一个数据元素出队时，rear会变成野指针，需要赋值为front

### 扩展

1. 一个数组两端可以同时实现两个顺序栈
2. 双端队列：两端都可以入队、出队
