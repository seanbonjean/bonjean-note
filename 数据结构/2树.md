# 树

基本结构：

根  
|-子树  
|-子树  
|-子树  
|- ......

并且是递归的，子树也可以拥有这样一个结构

## 一些概念

* 结点的度：结点拥有子树的个数
* 树的度：max{所有结点的度}
* 叶子结点：度为0的结点
* 分支结点：度不为0的结点
* 父结点、子结点、兄弟结点、祖先结点、子孙结点
* 路径：从任意一个结点出发，到另一个结点所经过的结点序列，两端连接祖先和子孙
* 路径长度：路径上经过的边的个数
* 结点的层次：从根开始，根为第一层，根的子结点为第二层，以此类推
* 树的深度：树中所有结点的最大层次
* 树的宽度：max{每层结点个数}
* 森林：树的集合

## 树的遍历

### 一般树

前序遍历、后序遍历、层序遍历

### 仅限二叉树

* 前序遍历：根结点->左子树->右子树
* 中序遍历：左子树->根结点->右子树
* 后序遍历：左子树->右子树->根结点
* 层序遍历

## 树的表示（存储结构）

1. 双亲表示法：记录每个结点的父结点  
    由{data, parent}元素组成的一维数组，其中parent为-1表示该结点为根结点

    |data|parent|
    |-|-|
    |data1|-1|
    |data2|0|
    |data3|0|
    |data4|0|
    |data5|1|
    |data6|1|
    |data7|3|

2. 孩子表示法：记录每个结点的子结点  
    由{data, first_child}元素组成的一维数组，其中first_child中存储的各地址分别指向各自**孩子链表**，链表中的元素为各子结点**对应下标**，以从左到右顺序排列

    |data|first_child|
    |-|-|
    |data1|address1|
    |data2|address2|
    |data3|NULL|
    |data4|address3|
    |data5|NULL|
    |data6|NULL|
    |data7|NULL|

    address1->{1, next}->{2, next}->{3, NULL}  
    address2->{4, next}->{5, NULL}  
    address3->{6, NULL}

3. 孩子兄弟表示法：记录第一个孩子和右兄弟
    |根指针| | |
    |:-:|:-:|:-:|
    |v| | |
    |{data1, first_child, NULL}| | |
    |v| | |
    |{data2, first_child, right_sibling} ->|{data3, NULL, right_sibling} ->|{data4, first_child, NULL}|
    |v| |v|
    |{data5, NULL, right_sibling} ->|{data6, NULL, NULL}|{data7, NULL, NULL}|

    （全部都是链接存储，没有数组）

上面三个示例表示的是同一棵树，可以对照查看进行理解

&ensp; &ensp; &ensp; &ensp; data1  
&ensp; &ensp; &ensp; /&ensp; &ensp; |&ensp; &ensp; \\  
data2&ensp; data3&ensp; data4  
&ensp; |&ensp; &ensp; \\&ensp; &ensp; &ensp; &ensp; &ensp; &ensp; |  
data5&ensp; data6&ensp; data7

## 二叉树

基本结构：

&ensp; &ensp; &ensp; &ensp; 根  
&ensp; &ensp; &ensp; /&ensp; &ensp; \\  
左子树&ensp; &ensp; 右子树

并且是递归的，子树也可以拥有这样一个结构

二叉树与树不同，不仅需要限制**度<=2**，还要求指明左/右子树

如：

&ensp; &ensp; A  
&ensp; /  
B

和：

A  
&ensp; \\  
&ensp; &ensp; B

是同一棵树，但却是不同的两棵二叉树

### 一些概念

* 斜树：
    - 左斜树：所有结点都只有左子树的二叉树
    - 右斜树：所有结点都只有右子树的二叉树
* 满二叉树：所有分支结点都有左右子树，并且所有叶子结点都在同一层上
* 完全二叉树：对满二叉树层序编号，然后允许摘除最底层最右边几个叶子结点

因此，满二叉树一定是完全二叉树

### 用遍历序列确定一颗二叉树

* 前/后序遍历序列 + 中序遍历序列可唯一确定一棵二叉树
* 扩展二叉树的任意遍历序列就能唯一确定原二叉树  
（扩展二叉树：给每个NULL接上一个虚结点，可令虚结点data='#'或其他特定值）

### 二叉树的存储结构

* 顺序存储：按照同规模满二叉树层序编号，然后用数组存储，编号对应数组下标（适合较“密集”的二叉树）
* 链接存储：
    - 二叉链表{Lchild, data, Rchild}
    - 三叉链表{Lchild, data, Rchild, parent}，parent指向父结点，方便回溯

### 最优二叉树

* 带权路径长度：在实际应用中，每个叶子结点可能会拥有一个权值，带权路径长度=sum{所有叶子节点的(结点权值*路径长度)}
* 最优二叉树（哈夫曼树）：带权路径长度最小的二叉树

#### 哈夫曼算法

1. 每个叶子结点单独作为一棵二叉树
2. 每次取权值最小的两棵二叉树合并，形成新的二叉树，根节点权值为左右子树权值之和
3. 重复2，直到只剩一棵二叉树

应用：哈夫曼编码压缩文件  
原文件为等长编码，通过不等长编码（如哈夫曼编码）对文件进行压缩，让出现频率高的字符拥有更短的编码  
方法：
1. 统计原文件中每个字符出现的频率，作为叶子结点的权值
2. 进行哈夫曼算法，得到最优二叉树
3. 通过哈夫曼树，得到每个字符对应的编码，从根节点开始，往左子树走一层为0，往右子树走一层为1

例如，若得到的最优二叉树为：

&ensp; node  
&ensp; /&ensp; &ensp; \\  
A&ensp; &ensp; node  
&ensp; &ensp; &ensp; /&ensp; &ensp; \\  
&ensp; &ensp; B&ensp; &ensp; &ensp; C

则可得到对应编码：
* A: 0
* B: 10
* C: 11
