# 排序和查找

## 排序

### 一些概念

* 内排序：记录都在内存里
* 外排序：记录在外部存储里，每次读部分记录进内存，分批排序
* 不稳定的排序：关键码相同的记录，排序前后，相对位置被改变的排序算法

### 二叉排序树

类似对分查找，将每个记录以二叉树形式组织：所有左子树上的记录的键值都比根结点的记录小，所有右子树上的记录的键值都比根结点的记录大

例：

&ensp; &ensp; &ensp; &ensp; &ensp; 63  
&ensp; &ensp; &ensp; /&ensp; &ensp; &ensp; &ensp; \\  
&ensp; &ensp; 55&ensp; &ensp; &ensp; &ensp; 90  
&ensp; &ensp; /&ensp; \\&ensp; &ensp; &ensp; /  
&ensp; 42&ensp; 58&ensp; 70  
&ensp; /&ensp; \\&ensp; &ensp; &ensp; /&ensp; \\  
10&ensp; 45&ensp; 67&ensp; 83

结点插入次序会影响二叉树的形态  
解决办法：平衡二叉树、B树

### 希尔排序

按一定步长间隔分组，分别对各组排序，每轮结束后缩小步长重新分组，循环直到步长为1，所有数据作为一整组进行整体排序后终止

### 快速排序

初始状态：

|轴| | | | | | | | | |
|-|-|-|-|-|-|-|-|-|-|
|i ->| | | | | | | | |<- j|

循环直到i == j：
1. 循环直到data[i]>data[j]：j--
2. 交换 data[i]和data[j]
3. 循环直到data[i]>data[j]：i++
4. 交换 data[i]和data[j]

i == j后，以该值为分界，划分为前后两个子序列

|#|#|#|#|#|轴|@|@|@|@|
|-|-|-|-|-|:-:|-|-|-|-|
| | | | | |i == j| | | | |

#: 前子序列  
@: 后子序列

对子序列重复上述过程，直到每个子序列都只剩一个记录

### 归并排序

思想：将序列分为两个子序列，先对子序列排序，再归并  
实际：因为对子序列排序仍然用归并，因此先会一直划分到每个序列只剩一个记录，然后两两归并直到只剩一个序列

## 查找

### 散列查找

通过散列函数，将记录的关键码变换为散列地址H(ki)，凭此到散列表中查找ki
